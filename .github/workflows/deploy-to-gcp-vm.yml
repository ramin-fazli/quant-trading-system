# Deploy Trading System to GCP VM
# 
# Required GitHub Secrets:
# - GCP_SA_KEY: Service account key JSON for GCP authentication
# - GCP_PROJECT_ID: Google Cloud Project ID
# - INFLUXDB_URL: InfluxDB connection URL
# - INFLUXDB_TOKEN: InfluxDB authentication token
# - INFLUXDB_ORG: InfluxDB organization
# - INFLUXDB_BUCKET: InfluxDB bucket name
# - MT5_LOGIN: MetaTrader 5 login (optional)
# - MT5_PASSWORD: MetaTrader 5 password (optional)
# - MT5_SERVER: MetaTrader 5 server (optional)
# - CTRADER_CLIENT_ID: cTrader API client ID
# - CTRADER_CLIENT_SECRET: cTrader API client secret
# - CTRADER_ACCESS_TOKEN: cTrader API access token
# - CTRADER_ACCOUNT_ID: cTrader account ID
# - CTRADER_HOST_TYPE: cTrader host type (demo/live)
# - TELEGRAM_BOT_TOKEN: Telegram bot token for notifications (optional)
# - TELEGRAM_CHAT_ID: Telegram chat ID for notifications (optional)
# - TRADING_PAIRS: Trading pairs configuration (optional, will use config/pairs.json if not set)

name: Deploy Trading System to GCP VM

on:
  push:
    branches: [ version/2.2 ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes'
        required: false
        default: false
        type: boolean

env:
  GAR_LOCATION: us-east4
  GAR_REPOSITORY: trading-system
  IMAGE_NAME: trading-system
  VM_ZONE: us-east4-c
  VM_NAME: instance-20250729-190934
  SERVICE_NAME: trading-system

jobs:
  # Job 1: Build and push to Artifact Registry (optimized)
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      id-token: write
      security-events: write

    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        platforms: linux/amd64

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      with:
        version: latest

    - name: Configure Docker for Artifact Registry
      run: |
        gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev --quiet

    - name: Create Artifact Registry repository (if needed)
      run: |
        gcloud artifacts repositories create ${{ env.GAR_REPOSITORY }} \
          --repository-format=docker \
          --location=${{ env.GAR_LOCATION }} \
          --project=${{ secrets.GCP_PROJECT_ID }} \
          --description="Trading system Docker images" 2>/dev/null || true

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.live
        platforms: linux/amd64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: |
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          VCS_REF=${{ github.sha }}
          BUILD_VERSION=${{ github.ref_name }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Security scan with Trivy
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ env.IMAGE_NAME }}:latest
        format: 'sarif'
        output: 'trivy-results.sarif'
      continue-on-error: true

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'
      continue-on-error: true

  # Job 2: Deploy to GCP VM
  deploy-to-vm:
    name: Deploy to GCP VM
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/version/2.2' || github.event_name == 'workflow_dispatch'

    steps:
    - name: Checkout deployment scripts
      uses: actions/checkout@v4
      with:
        sparse-checkout: |
          scripts/
          docker-compose.yml
          .env.example

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    - name: Verify VM exists and is running
      run: |
        echo "üîç Checking VM status..."
        VM_STATUS=$(gcloud compute instances describe ${{ env.VM_NAME }} \
          --zone=${{ env.VM_ZONE }} \
          --project=${{ secrets.GCP_PROJECT_ID }} \
          --format="value(status)")
        
        if [ "$VM_STATUS" != "RUNNING" ]; then
          echo "‚ö†Ô∏è VM is not running (status: $VM_STATUS)"
          if [ "$VM_STATUS" = "TERMINATED" ]; then
            echo "üöÄ Starting VM..."
            gcloud compute instances start ${{ env.VM_NAME }} \
              --zone=${{ env.VM_ZONE }} \
              --project=${{ secrets.GCP_PROJECT_ID }}
            
            # Wait for VM to be ready
            echo "‚è≥ Waiting for VM to be ready..."
            sleep 30
          fi
        fi
        
        echo "‚úÖ VM is ready for deployment"

    - name: Create deployment script
      run: |
        cat > deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "üöÄ Starting deployment on VM..."
        
        # Set variables
        IMAGE_NAME="${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ env.IMAGE_NAME }}:latest"
        SERVICE_NAME="${{ env.SERVICE_NAME }}"
        
        # Create application directory with proper structure
        sudo mkdir -p /opt/trading-system/{logs,data,backtest_reports,cache,config}
        cd /opt/trading-system
        
        # Ensure current user is in docker group and refresh group membership
        sudo usermod -aG docker $USER
        sudo usermod -aG docker ubuntu 2>/dev/null || true
        
        # Authenticate Docker with GCP (use sudo if needed)
        echo "üîê Authenticating Docker with GCP..."
        if docker info >/dev/null 2>&1; then
            gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev --quiet
        else
            echo "Using sudo for Docker commands due to permission issues..."
            sudo -u root bash -c "gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev --quiet"
        fi
        
        # Pull latest image (with fallback to sudo)
        echo "üì• Pulling latest Docker image..."
        if docker info >/dev/null 2>&1; then
            docker pull "$IMAGE_NAME"
        else
            sudo docker pull "$IMAGE_NAME"
        fi
        
        # Stop existing container if running (with fallback to sudo)
        echo "üõë Stopping existing service..."
        if docker info >/dev/null 2>&1; then
            docker stop "$SERVICE_NAME" 2>/dev/null || true
            docker rm "$SERVICE_NAME" 2>/dev/null || true
        else
            sudo docker stop "$SERVICE_NAME" 2>/dev/null || true
            sudo docker rm "$SERVICE_NAME" 2>/dev/null || true
        fi
        
        # Clean up old images (keep last 3) (with fallback to sudo)
        echo "üßπ Cleaning up old images..."
        if docker info >/dev/null 2>&1; then
            docker images "${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ env.IMAGE_NAME }}" --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | tail -n +2 | head -n -3 | awk '{print $1}' | xargs -r docker rmi || true
        else
            sudo docker images "${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ env.IMAGE_NAME }}" --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | tail -n +2 | head -n -3 | awk '{print $1}' | xargs -r sudo docker rmi || true
        fi
        
        echo "üéâ Deployment completed successfully!"
        EOF
        
        chmod +x deploy.sh

    - name: Create environment file
      run: |
        cat > .env << 'EOF'
        # === Production Environment Configuration ===
        ENVIRONMENT=production
        LOG_LEVEL=INFO
        
        # === Port Configuration ===
        DASHBOARD_PORT=8050
        API_PORT=8000
        INFLUXDB_PORT=8086
        REDIS_PORT=6379
        
        # === Trading Mode Configuration ===
        TRADING_MODE=live
        
        # === Trading Strategy Configuration ===
        DATA_PROVIDER=ctrader
        BROKER=ctrader
        TRADING_INTERVAL=M15
        TRADING_START_DATE=2025-06-28
        
        # === Strategy Parameters ===
        Z_ENTRY=2.0
        Z_EXIT=0.5
        Z_PERIOD=100
        MIN_DISTANCE=0
        MIN_VOLATILITY=0
        ENABLE_ADF=false
        MAX_ADF_PVAL=0.05
        ADF_PERIOD=100
        ENABLE_JOHANSEN=false
        JOHANSEN_CRIT_LEVEL=95
        ENABLE_CORRELATION=false
        MIN_CORR=0.7
        CORR_PERIOD=100
        ENABLE_VOL_RATIO=false
        VOL_RATIO_MAX=2
        DYNAMIC_Z=false
        
        # === Risk Management Parameters ===
        TAKE_PROFIT_PERC=5
        STOP_LOSS_PERC=5
        TRAILING_STOP_PERC=10
        COOLDOWN_BARS=0
        MAX_POSITION_SIZE=500
        MAX_OPEN_POSITIONS=10
        MAX_MONETARY_EXPOSURE=100000
        MONETARY_VALUE_TOLERANCE=0.05
        MAX_COMMISSION_PERC=0.2
        COMMISSION_FIXED=0.02
        SLIPPAGE_POINTS=3
        MAX_PAIR_DRAWDOWN_PERC=5
        MAX_PORTFOLIO_DRAWDOWN_PERC=10
        INITIAL_PORTFOLIO_VALUE=100000.0
        
        # === System Parameters ===
        USE_MULTIPROCESSING=true
        MAX_WORKERS=8
        REALTIME_TRADING=true
        
        # === Notification Settings ===
        ENABLE_TRADE_ALERTS=true
        ENABLE_SYSTEM_ALERTS=true
        ENABLE_PERFORMANCE_ALERTS=true
        
        # === State Management Database Configuration ===
        TRADING_STATE_DB_TYPE=influxdb
        TRADING_STATE_ENABLE_VALIDATION=true
        TRADING_STATE_ENABLE_FILE_FALLBACK=true
        TRADING_STATE_LOG_LEVEL=WARNING
        
        # === API Configuration ===
        TRADING_STATE_API_ENABLED=true
        TRADING_STATE_API_HOST=0.0.0.0
        TRADING_STATE_API_PORT=8000
        EOF
        
        # Add secrets to environment file
        echo "INFLUXDB_URL=${{ secrets.INFLUXDB_URL }}" >> .env
        echo "INFLUXDB_TOKEN=${{ secrets.INFLUXDB_TOKEN }}" >> .env
        echo "INFLUXDB_ORG=${{ secrets.INFLUXDB_ORG }}" >> .env
        echo "INFLUXDB_BUCKET=${{ secrets.INFLUXDB_BUCKET }}" >> .env
        echo "CTRADER_CLIENT_ID=${{ secrets.CTRADER_CLIENT_ID }}" >> .env
        echo "CTRADER_CLIENT_SECRET=${{ secrets.CTRADER_CLIENT_SECRET }}" >> .env
        echo "CTRADER_ACCESS_TOKEN=${{ secrets.CTRADER_ACCESS_TOKEN }}" >> .env
        echo "CTRADER_ACCOUNT_ID=${{ secrets.CTRADER_ACCOUNT_ID }}" >> .env
        echo "CTRADER_HOST_TYPE=${{ secrets.CTRADER_HOST_TYPE }}" >> .env
        
        # Add trading pairs - use secret if provided, otherwise use default pairs
        if [ -n "${{ secrets.TRADING_PAIRS }}" ]; then
          echo "TRADING_PAIRS=${{ secrets.TRADING_PAIRS }}" >> .env
        else
          echo "TRADING_PAIRS=BTCUSD-ETHUSD,BTCUSD-SOLUSD,ETHUSD-SOLUSD" >> .env
        fi
        
        # Add state management secrets
        echo "TRADING_STATE_INFLUXDB_URL=${{ secrets.INFLUXDB_URL }}" >> .env
        echo "TRADING_STATE_INFLUXDB_TOKEN=${{ secrets.INFLUXDB_TOKEN }}" >> .env
        echo "TRADING_STATE_INFLUXDB_ORG=${{ secrets.INFLUXDB_ORG }}" >> .env
        echo "TRADING_STATE_INFLUXDB_BUCKET=${{ secrets.INFLUXDB_BUCKET }}" >> .env

    - name: Create trading pairs configuration file
      run: |
        # Create empty pairs.json file as fallback
        cat > pairs.json << 'EOF'
        []
        EOF

    - name: Create container start script
      run: |
        cat > start-container.sh << 'EOF'
        #!/bin/bash
        set -e
        
        SERVICE_NAME="${{ env.SERVICE_NAME }}"
        IMAGE_NAME="${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ env.IMAGE_NAME }}:latest"
        
        # Determine if we need to use sudo for docker commands
        USE_SUDO=""
        if ! docker info >/dev/null 2>&1; then
            echo "Using sudo for Docker commands due to permission issues..."
            USE_SUDO="sudo"
        fi
        
        # Ensure .env file exists in the correct location
        if [ ! -f "/opt/trading-system/.env" ]; then
            echo "‚ùå Environment file not found at /opt/trading-system/.env"
            exit 1
        fi
        
        # Ensure config directory and pairs.json exist
        if [ ! -f "/opt/trading-system/config/pairs.json" ]; then
            echo "‚ö†Ô∏è Pairs configuration file not found, creating empty fallback..."
            echo '[]' | sudo tee /opt/trading-system/config/pairs.json > /dev/null
        fi
        
        # Start new container
        echo "üöÄ Starting new service..."
        $USE_SUDO docker run -d \
          --name "$SERVICE_NAME" \
          --restart unless-stopped \
          -p 8050:8050 \
          -p 8080:8080 \
          --env-file /opt/trading-system/.env \
          -v /opt/trading-system/logs:/app/logs \
          -v /opt/trading-system/data:/app/data \
          -v /opt/trading-system/backtest_reports:/app/backtest_reports \
          -v /opt/trading-system/cache:/app/cache \
          -v /opt/trading-system/config:/app/config \
          --memory=4g \
          --cpus=2 \
          --log-driver=json-file \
          --log-opt max-size=100m \
          --log-opt max-file=5 \
          "$IMAGE_NAME"
        
        # Verify deployment
        echo "üîç Verifying deployment..."
        sleep 10
        
        if $USE_SUDO docker ps | grep -q "$SERVICE_NAME"; then
          echo "‚úÖ Service is running successfully!"
          $USE_SUDO docker logs --tail 20 "$SERVICE_NAME"
        else
          echo "‚ùå Service failed to start!"
          $USE_SUDO docker logs "$SERVICE_NAME"
          exit 1
        fi
        
        # Health check
        echo "üè• Performing health check..."
        for i in {1..12}; do
          if curl -f http://localhost:8050 >/dev/null 2>&1; then
            echo "‚úÖ Health check passed!"
            break
          fi
          echo "‚è≥ Waiting for service to be ready... ($i/12)"
          sleep 10
        done
        
        # Display service info
        echo "üìä Service Information:"
        echo "Container ID: $($USE_SUDO docker ps -q -f name=$SERVICE_NAME)"
        echo "Image: $IMAGE_NAME"
        echo "Status: $($USE_SUDO docker inspect -f '{{.State.Status}}' $SERVICE_NAME)"
        echo "Started: $($USE_SUDO docker inspect -f '{{.State.StartedAt}}' $SERVICE_NAME)"
        EOF
        
        chmod +x start-container.sh

    - name: Deploy to VM via SSH
      run: |
        # Add VM to known hosts
        gcloud compute ssh ${{ env.VM_NAME }} \
          --zone=${{ env.VM_ZONE }} \
          --project=${{ secrets.GCP_PROJECT_ID }} \
          --command="echo 'SSH connection test successful'" \
          --ssh-flag="-o StrictHostKeyChecking=no"
        
        # Copy deployment script to VM
        gcloud compute scp deploy.sh ${{ env.VM_NAME }}:~/deploy.sh \
          --zone=${{ env.VM_ZONE }} \
          --project=${{ secrets.GCP_PROJECT_ID }}
        
        # Copy environment file to VM
        gcloud compute scp .env ${{ env.VM_NAME }}:~/trading-system.env \
          --zone=${{ env.VM_ZONE }} \
          --project=${{ secrets.GCP_PROJECT_ID }}
        
        # Copy pairs configuration to VM
        gcloud compute scp pairs.json ${{ env.VM_NAME }}:~/pairs.json \
          --zone=${{ env.VM_ZONE }} \
          --project=${{ secrets.GCP_PROJECT_ID }}
        
        # Copy container start script to VM
        gcloud compute scp start-container.sh ${{ env.VM_NAME }}:~/start-container.sh \
          --zone=${{ env.VM_ZONE }} \
          --project=${{ secrets.GCP_PROJECT_ID }}
        
        # Execute deployment on VM
        gcloud compute ssh ${{ env.VM_NAME }} \
          --zone=${{ env.VM_ZONE }} \
          --project=${{ secrets.GCP_PROJECT_ID }} \
          --command="chmod +x ~/deploy.sh && ~/deploy.sh && sudo mv ~/trading-system.env /opt/trading-system/.env && sudo mv ~/pairs.json /opt/trading-system/config/pairs.json && sudo chown -R \$USER:\$USER /opt/trading-system && chmod +x ~/start-container.sh && cd /opt/trading-system && ~/start-container.sh"

    - name: Post-deployment verification
      run: |
        # Get VM external IP
        VM_IP=$(gcloud compute instances describe ${{ env.VM_NAME }} \
          --zone=${{ env.VM_ZONE }} \
          --project=${{ secrets.GCP_PROJECT_ID }} \
          --format="value(networkInterfaces[0].accessConfigs[0].natIP)")
        
        echo "üåê VM External IP: $VM_IP"
        
        # Final health check from outside
        echo "üîç External health check..."
        for i in {1..6}; do
          if curl -f "http://$VM_IP:8050" >/dev/null 2>&1; then
            echo "‚úÖ External health check passed!"
            echo "üéØ Dashboard URL: http://$VM_IP:8050"
            break
          fi
          echo "‚è≥ Waiting for external access... ($i/6)"
          sleep 10
        done

    - name: Notify deployment status
      if: always()
      run: |
        # Get VM external IP
        VM_IP=$(gcloud compute instances describe ${{ env.VM_NAME }} \
          --zone=${{ env.VM_ZONE }} \
          --project=${{ secrets.GCP_PROJECT_ID }} \
          --format="value(networkInterfaces[0].accessConfigs[0].natIP)")
        
        if [ "${{ job.status }}" = "success" ]; then
          echo "‚úÖ Deployment completed successfully!"
          echo "üìä Service Status: Active"
          echo "üîó Dashboard: http://$VM_IP:8050"
        else
          echo "‚ùå Deployment failed!"
          echo "üìã Check the logs above for details"
        fi

  # Job 3: Cleanup (optional)
  cleanup:
    name: Cleanup Old Resources
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-to-vm]
    if: success() && github.ref == 'refs/heads/version/2.2'
    
    steps:
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    - name: Cleanup old images
      run: |
        echo "üßπ Cleaning up old Docker images in Artifact Registry..."
        
        # Keep only the last 10 images
        gcloud artifacts docker images list \
          ${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ env.IMAGE_NAME }} \
          --sort-by="~CREATE_TIME" \
          --limit=100 \
          --format="value(IMAGE)" | tail -n +11 | while read image; do
          echo "Deleting old image: $image"
          gcloud artifacts docker images delete "$image" --quiet || true
        done
        
        echo "‚úÖ Cleanup completed"
